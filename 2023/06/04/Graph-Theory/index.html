<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Graph Theory | 一直进步 做喜欢的</title><meta name="keywords" content="Data Structures and Algorithms,LeetCode"><meta name="author" content="贪钱算法还我头发"><meta name="copyright" content="贪钱算法还我头发"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="算法——图论">
<meta property="og:type" content="article">
<meta property="og:title" content="Graph Theory">
<meta property="og:url" content="https://xfliu1998.github.io/2023/06/04/Graph-Theory/index.html">
<meta property="og:site_name" content="一直进步 做喜欢的">
<meta property="og:description" content="算法——图论">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://img.shijue.me/845aa0476235409e9ef646afb7c05ab7_d.jpg!dp6">
<meta property="article:published_time" content="2023-06-04T04:00:00.000Z">
<meta property="article:modified_time" content="2023-12-25T02:38:36.265Z">
<meta property="article:author" content="贪钱算法还我头发">
<meta property="article:tag" content="Data Structures and Algorithms">
<meta property="article:tag" content="LeetCode">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://img.shijue.me/845aa0476235409e9ef646afb7c05ab7_d.jpg!dp6"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://xfliu1998.github.io/2023/06/04/Graph-Theory/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: 'days',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Graph Theory',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-12-25 10:38:36'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/StaticFile_HEXO@latest/butterfly/css/pool.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/StaticFile_HEXO@latest/butterfly/css/iconfont.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/StaticFile_HEXO@latest/butterfly/js/pool.min.js"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/mouse_snow.min.js"><link rel="stylesheet" href="/css/custom.css?v1"><link rel="stylesheet" href="//at.alicdn.com/t/font_2264842_b004iy0kk2b.css" media="defer" onload="this.media='all'"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/images/head.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">57</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">15</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">6</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('http://img.shijue.me/845aa0476235409e9ef646afb7c05ab7_d.jpg!dp6')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">一直进步 做喜欢的</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Graph Theory</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-06-04T04:00:00.000Z" title="Created 2023-06-04 12:00:00">2023-06-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-12-25T02:38:36.265Z" title="Updated 2023-12-25 10:38:36">2023-12-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Data-Structures-and-Algorithms/">Data Structures and Algorithms</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word count:</span><span class="word-count">6.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading time:</span><span>23min</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Graph Theory"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">Comments:</span><a href="/2023/06/04/Graph-Theory/#post-comment"><span class="gitalk-comment-count"></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h1><p>基本知识点：</p>
<ul>
<li>顶点（Vertex）：图由一组顶点组成，每个顶点可以表示一个实体或对象。</li>
<li>边（Edge）：顶点之间的连接关系称为边。边可以是有向的（从一个顶点指向另一个顶点）或无向的（没有方向性）。</li>
<li>权重（Weight）：在有权图中，每条边可能会有一个与之关联的权重，用于表示顶点之间的距离、成本或其他度量。</li>
<li>度（Degree）：在无向图中，度就是每个节点相连的边的条数。对于有向图，分为入度（指向该顶点的边的数量）和出度（从该顶点出发的边的数量）。</li>
<li>邻接顶点（Adjacent Vertices）：对于一个顶点，与之直接相连的顶点称为邻接顶点。</li>
<li>路径（Path）：图中的路径是指由边连接的顶点序列。路径的长度是指路径上的边的数量。</li>
<li>环（Cycle）：如果路径的起点和终点是同一个顶点，并且没有重复的边，则称该路径为环。</li>
<li>连通图（Connected Graph）：在无向图中，如果任意两个顶点之间都存在路径，则该图被称为连通图。</li>
<li>强连通图（Strongly Connected Graph）：在有向图中，如果任意两个顶点之间都存在双向路径，则该图被称为强连通图。</li>
<li>最短路径（Shortest Path）：在带权图中，最短路径是指连接两个顶点之间权重和最小的路径。</li>
<li>图的表示方法：图可以使用邻接矩阵、邻接表等方式进行表示。邻接矩阵是一个二维矩阵，用于表示顶点之间的连接关系。邻接表是使用链表或数组表示每个顶点及其邻接顶点的列表。相比于邻接矩阵，邻接表需要的存储空间少，但是无法快速判断两个节点是否相邻。</li>
<li>最小生成树（Minimum Spanning Tree）：在带权无向图中，最小生成树是指连接图中所有顶点，并且边的权重和最小的树。</li>
<li>常见的图算法：常见的图算法包括深度优先搜索（DFS）、广度优先搜索（BFS）、Dijkstra算法（用于寻找最短路径）、拓扑排序、Prim算法和Kruskal算法（用于求最小生成树）等。</li>
<li>图的遍历代码：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 记录被遍历过的节点</span></span><br><span class="line">visited = []</span><br><span class="line"><span class="comment"># 记录从起点到当前节点的路径，用于判断是否成环</span></span><br><span class="line">onPath = []</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot; 图遍历框架 &quot;&quot;&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">traverse</span>(<span class="params">graph, s</span>):</span></span><br><span class="line">    <span class="keyword">if</span> visited[s]:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 经过节点 s，标记为已遍历</span></span><br><span class="line">    visited[s] = <span class="literal">True</span></span><br><span class="line">    <span class="comment"># 做选择：标记节点 s 在路径上</span></span><br><span class="line">    onPath[s] = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">for</span> neighbor <span class="keyword">in</span> graph.neighbors(s):</span><br><span class="line">        traverse(graph, neighbor)</span><br><span class="line">    <span class="comment"># 撤销选择：节点 s 离开路径</span></span><br><span class="line">    onPath[s] = <span class="literal">False</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="常见图算法"><a href="#常见图算法" class="headerlink" title="常见图算法"></a>常见图算法</h2><h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p>拓扑排序（Topological Sorting）是一种对有向无环图（DAG）进行排序的算法。它可以找到一个满足所有依赖关系的顺序，使得对于图中的每一对有向边 (u, v)，顶点 u 都在顶点 v 之前。通俗说即把一幅图「拉平」，且这个「拉平」的图里面所有箭头方向都是一致的。如果一幅有向图中存在环是无法进行拓扑排序的，因为肯定做不到所有箭头方向一致；反过来，如果一幅图是「有向无环图」，那么一定可以进行拓扑排序。</p>
<ul>
<li>基本思想：通过不断移除图中的入度为 0 的顶点，直到所有顶点都被处理完毕。</li>
<li>具体步骤：<ul>
<li>初始化：创建一个空的结果列表 result，以及一个队列 queue。</li>
<li>计算顶点的入度：遍历有向图的所有顶点，计算每个顶点的入度（即指向该顶点的边的数量），并将入度为 0 的顶点加入队列 queue。</li>
<li>拓扑排序：不断从队列中取出顶点，将其加入结果列表 result，并将其相邻顶点的入度减 1。如果减 1 后的入度为 0，将该顶点加入队列。</li>
<li>输出结果：当队列为空时，所有顶点都已经被处理，并且按照拓扑排序的顺序加入了结果列表 result。将结果列表 result 返回作为拓扑排序的结果。</li>
</ul>
</li>
<li>时间复杂度为 $O(V + E)$，其中 V 表示顶点的数量，E 表示边的数量。这是因为每个顶点和每条边都需要被访问一次。</li>
<li>代码：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">topological_sort</span>(<span class="params">graph</span>):</span></span><br><span class="line">    <span class="comment"># 统计每个顶点的入度</span></span><br><span class="line">    in_degree = &#123;v: <span class="number">0</span> <span class="keyword">for</span> v <span class="keyword">in</span> graph&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算每个顶点的入度</span></span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> graph:</span><br><span class="line">        <span class="keyword">for</span> neighbor <span class="keyword">in</span> graph[v]:</span><br><span class="line">            in_degree[neighbor] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建一个队列用于存储入度为0的顶点</span></span><br><span class="line">    queue = deque([v <span class="keyword">for</span> v <span class="keyword">in</span> in_degree <span class="keyword">if</span> in_degree[v] == <span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 存储拓扑排序的结果</span></span><br><span class="line">    result = []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 执行拓扑排序</span></span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        v = queue.popleft()</span><br><span class="line">        result.append(v)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将相邻顶点的入度减1，并将入度变为0的顶点加入队列</span></span><br><span class="line">        <span class="keyword">for</span> neighbor <span class="keyword">in</span> graph[v]:</span><br><span class="line">            in_degree[neighbor] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> in_degree[neighbor] == <span class="number">0</span>:</span><br><span class="line">                queue.append(neighbor)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果图中存在环路，则无法进行拓扑排序</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(result) != <span class="built_in">len</span>(graph):</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;The graph contains a cycle.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">graph = &#123;</span><br><span class="line">    <span class="string">&#x27;A&#x27;</span>: [<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;B&#x27;</span>: [<span class="string">&#x27;D&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;C&#x27;</span>: [<span class="string">&#x27;D&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;D&#x27;</span>: [<span class="string">&#x27;E&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;E&#x27;</span>: []</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result = topological_sort(graph)</span><br><span class="line"><span class="built_in">print</span>(result)    <span class="comment"># [&#x27;A&#x27;, &#x27;C&#x27;, &#x27;B&#x27;, &#x27;D&#x27;, &#x27;E&#x27;]</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h3><p>二分图（Bipartite Graph），也称为二部图，是图论中一种特殊的图结构。</p>
<ul>
<li>基本概念：二分图是指一个图可以将所有顶点分为两个不相交的顶点集合，且图中的每条边的两个端点分别属于不同的顶点集合。</li>
<li>判断：判断一个图是否为二分图有多种方法，其中最常用的方法是使用深度优先搜索（DFS）或广度优先搜索（BFS）进行染色。通过从任意一个顶点开始，将其染成一种颜色，然后按照染色规则继续染色相邻的顶点，如果在染色过程中发现相邻顶点已经染成了相同的颜色，则图不是二分图；如果染色完成后没有发现相邻顶点染成相同的颜色，则图是二分图。</li>
<li>应用：二分图可以用于建模和解决各种问题，例如匹配问题、调度问题、分配问题等。最大匹配问题可以在二分图上求解，而匈牙利算法是常用于解决最大匹配问题的算法之一。</li>
<li>代码：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_bipartite</span>(<span class="params">graph</span>):</span></span><br><span class="line">    <span class="comment"># 定义三种颜色：0 表示未染色，1 表示染成红色，-1 表示染成蓝色</span></span><br><span class="line">    colors = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">node, color</span>):</span></span><br><span class="line">        colors[node] = color</span><br><span class="line">        <span class="keyword">for</span> neighbor <span class="keyword">in</span> graph[node]:</span><br><span class="line">            <span class="keyword">if</span> neighbor <span class="keyword">not</span> <span class="keyword">in</span> colors:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> dfs(neighbor, -color):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">elif</span> colors[neighbor] == color:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 对每个顶点进行DFS染色判断</span></span><br><span class="line">    <span class="keyword">for</span> node <span class="keyword">in</span> graph:</span><br><span class="line">        <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> colors:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> dfs(node, <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">graph = &#123;</span><br><span class="line">    <span class="string">&#x27;A&#x27;</span>: [<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;B&#x27;</span>: [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;D&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;C&#x27;</span>: [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;D&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;D&#x27;</span>: [<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;E&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;E&#x27;</span>: [<span class="string">&#x27;D&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result = is_bipartite(graph)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><p>并查集（Union-Find）算法是一个专门针对「动态连通性」的算法。</p>
<ul>
<li>「连通」是一种等价关系，也就是说具有如下三个性质：<ol>
<li>自反性：节点 p 和 p 是连通的。</li>
<li>对称性：如果节点 p 和 q 连通，那么 q 和 p 也连通。</li>
<li>传递性：如果节点 p 和 q 连通，q 和 r 连通，那么 p 和 r 也连通。</li>
</ol>
</li>
<li>UF时间复杂度：<ul>
<li>find 主要功能就是从某个节点向上遍历到树根，其时间复杂度就是树的高度。我们可能习惯性地认为树的高度就是 logN，但这并不一定。logN 的高度只存在于平衡二叉树，对于一般的树可能出现极端不平衡的情况，使得「树」几乎退化成「链表」，树的高度最坏情况下可能变成 N。find, union, connected 的时间复杂度都是 O(N)。</li>
<li>平衡性优化（按秩合并）+路径压缩：构造函数初始化数据结构需要 O(N) 的时间和空间复杂度；连通两个节点 union、判断两个节点的连通性 connected、计算连通分量 count 所需的时间复杂度均为 O(1)。</li>
</ul>
</li>
<li>平衡性优化（按秩合并）+路径压缩：<ol>
<li>用 parent 数组记录每个节点的父节点，相当于指向父节点的指针，所以 parent 数组内实际存储着一个森林（若干棵多叉树）。</li>
<li>用 size 数组记录着每棵树的重量，目的是让 union 后树依然拥有平衡性，保证各个 API 时间复杂度为 O(logN)，而不会退化成链表影响操作效率。</li>
<li>在 find 函数中进行路径压缩，保证任意树的高度保持在常数，使得各个 API 时间复杂度为 O(1)。使用了路径压缩之后，可以不使用 size 数组的平衡优化。</li>
</ol>
</li>
<li>tip：二维坐标映射到一维的常用技巧：二维坐标 (x,y) 可以转换成 x * n + y 这个数（m 是棋盘的行数，n 是棋盘的列数）</li>
<li>代码：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UF</span>:</span></span><br><span class="line">    <span class="comment"># 连通分量个数</span></span><br><span class="line">    count: <span class="built_in">int</span></span><br><span class="line">    <span class="comment"># 存储每个节点的父节点</span></span><br><span class="line">    parent: <span class="type">List</span>[<span class="built_in">int</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># n 为图中节点的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, n: <span class="built_in">int</span></span>):</span></span><br><span class="line">        self.count = n</span><br><span class="line">        self.parent = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]  <span class="comment"># 初始时，每个元素的父节点指向自身</span></span><br><span class="line">        self.rank = [<span class="number">0</span>] * size  <span class="comment"># 记录每个集合的秩（树的高度）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将节点 p 和节点 q 连通</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">union</span>(<span class="params">self, p: <span class="built_in">int</span>, q: <span class="built_in">int</span></span>):</span></span><br><span class="line">        rootP = self.find(p)</span><br><span class="line">        rootQ = self.find(q)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> rootP == rootQ:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># self.parent[rootQ] = rootP</span></span><br><span class="line">        <span class="keyword">if</span> rootP != rootQ:</span><br><span class="line">            <span class="keyword">if</span> self.rank[rootP] &lt; self.rank[rootQ]:</span><br><span class="line">                self.parent[rootP] = rootQ</span><br><span class="line">            <span class="keyword">elif</span> self.rank[rootP] &gt; self.rank[rootQ]:</span><br><span class="line">                self.parent[rootQ] = rootP</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.parent[rootQ] = rootP</span><br><span class="line">                self.rank[rootP] += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 两个连通分量合并成一个连通分量</span></span><br><span class="line">        self.count -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 判断节点 p 和节点 q 是否连通</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connected</span>(<span class="params">self, p: <span class="built_in">int</span>, q: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        rootP = self.find(p)</span><br><span class="line">        rootQ = self.find(q)</span><br><span class="line">        <span class="keyword">return</span> rootP == rootQ</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.parent[x] != x:   <span class="comment"># 递归查找根节点，并进行路径压缩</span></span><br><span class="line">            self.parent[x] = self.find(self.parent[x])</span><br><span class="line">        <span class="keyword">return</span> self.parent[x]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 返回图中的连通分量个数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">count</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.count</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    fa = list(range(m * n))</span></span><br><span class="line"><span class="string">    def find(x):</span></span><br><span class="line"><span class="string">        if fa[x] != x:</span></span><br><span class="line"><span class="string">            fa[x] = find(fa[x])</span></span><br><span class="line"><span class="string">        return fa[x]</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    def union((x, y), (i, j)):</span></span><br><span class="line"><span class="string">        fa[find(x * n + y)] = fa[find(i * n + j)]</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><p>最小生成树（Minimum Spanning Tree，MST）算法是用于在连通加权图中找到一棵生成树，使得树上所有边的权重之和最小。生成树是原图的一个子图，它包含了所有的顶点和一部分边，且形成一个无环连通图。最小生成树算法主要有 Prim 算法（普里姆算法）和 Kruskal 算法（克鲁斯卡尔算法）两种，这两种算法虽然都运用了贪心思想。</p>
<ul>
<li>贪心思路：将所有边按照权重从小到大排序，从权重最小的边开始遍历，如果这条边和最小生成树中的其它边不会形成环，则这条边是最小生成树的一部分，将它加入最小生成树集合；否则，这条边不是最小生成树的一部分，不要把它加入最小生成树集合。</li>
<li>Prim 算法：Prim 算法是从一个起点的切分（一组横切边）开始执行类似 BFS 算法的逻辑，借助切分定理和优先级队列动态排序的特性，从这个起点「生长」出一棵最小生成树。它以贪心的方式选择边，每次选择与当前生成树连接的最小权重边所连接的顶点，并将该边加入生成树。Prim 算法可以使用优先队列来选择最小权重边，保证了边的选择是按照权重递增的顺序进行的。Prim 算法不需要事先对所有边排序，而是利用优先级队列动态实现排序的效果，Prim 算法类似于 Kruskal 的动态过程。每次切分都能找到最小生成树的一条边，然后又可以进行新一轮切分，直到找到最小生成树的所有边为止。<ul>
<li>复杂度分析：假设一幅图的节点个数为V，边的条数为E，首先需要O(E)的空间装所有边，而且 Union-Find 算法也需要O(V)的空间，所以 Kruskal 算法总的空间复杂度就是O(V + E)。时间复杂度主要耗费在排序，需要O(ElogE)的时间，Union-Find 算法所有操作的复杂度都是O(1)，套一个 for 循环也不过是O(E)，所以总的时间复杂度为O(ElogE)。</li>
</ul>
</li>
<li>Kruskal 算法：Kruskal 算法将图中的边按权重排序，然后从最小权重边开始逐步添加到生成树中。在添加边的过程中，需要确保不形成环路，即新添加的边与已有的边不构成环。Kruskal 算法使用并查集数据结构来判断边的两个顶点是否处于同一个连通分量，从而避免形成环路。<ul>
<li>时间复杂度：复杂度主要在优先级队列 pq 的操作上，由于 pq 里面装的是图中的「边」，假设一幅图边的条数为 E，那么最多操作 O(E) 次 pq。每次操作优先级队列的时间复杂度取决于队列中的元素个数，取最坏情况就是 O(logE)。所以总的时间复杂度为O(ElogE)。</li>
</ul>
</li>
<li>代码：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> heappop, heappush</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">prim</span>(<span class="params">graph</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(graph)</span><br><span class="line">    visited = [<span class="literal">False</span>] * n</span><br><span class="line">    min_heap = []</span><br><span class="line">    min_span_tree = []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 从顶点 0 开始构建最小生成树</span></span><br><span class="line">    start_vertex = <span class="number">0</span></span><br><span class="line">    heappush(min_heap, (<span class="number">0</span>, start_vertex))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> min_heap:</span><br><span class="line">        weight, vertex = heappop(min_heap)</span><br><span class="line">        <span class="keyword">if</span> visited[vertex]:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        visited[vertex] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> weight != <span class="number">0</span>:</span><br><span class="line">            min_span_tree.append((weight, vertex))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> neighbor, edge_weight <span class="keyword">in</span> graph[vertex]:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> visited[neighbor]:</span><br><span class="line">                heappush(min_heap, (edge_weight, neighbor))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> min_span_tree</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kruskal</span>(<span class="params">graph</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(graph)</span><br><span class="line">    disjoint_set = DisjointSet(n)</span><br><span class="line">    min_span_tree = []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将图中的边按权重排序</span></span><br><span class="line">    edges = [(weight, u, v) <span class="keyword">for</span> u <span class="keyword">in</span> <span class="built_in">range</span>(n) <span class="keyword">for</span> v, weight <span class="keyword">in</span> graph[u]]</span><br><span class="line">    edges.sort()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> weight, u, v <span class="keyword">in</span> edges:</span><br><span class="line">        <span class="keyword">if</span> disjoint_set.find(u) != disjoint_set.find(v):</span><br><span class="line">            disjoint_set.union(u, v)</span><br><span class="line">            min_span_tree.append(weight)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="最短路径算法"><a href="#最短路径算法" class="headerlink" title="最短路径算法"></a>最短路径算法</h2><h3 id="Floyd-Warshall"><a href="#Floyd-Warshall" class="headerlink" title="Floyd-Warshall"></a>Floyd-Warshall</h3><p>Floyd-Warshall 算法是一种用于求解所有顶点对之间（多源）最短路径的算法。它可以处理带有正权边或负权边的有向图或无向图，但不适用于存在负权环的情况。</p>
<ul>
<li>基本思想：通过动态规划的方式逐步计算每对顶点之间的最短路径。它维护一个二维数组，称为距离矩阵，其中的元素 dist[u][v] 表示顶点 u 到顶点 v 的最短路径的长度。</li>
<li>基本步骤：<ol>
<li>初始化：将距离矩阵的对角线元素设为 0，表示每个顶点到自身的距离为 0。对于有边相连的顶点，将距离矩阵的相应位置设为边的权重；对于没有边相连的顶点，将距离矩阵的相应位置设为无穷大。</li>
<li>迭代更新：对于每个顶点 k，依次考虑所有顶点对 (i, j) 的距离。如果通过顶点 k 可以获得更短的路径，则更新距离矩阵中的值 dist[i][j]。</li>
<li>返回结果：最终的距离矩阵就是所有顶点对之间的最短路径。</li>
</ol>
</li>
<li>代码：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">INF = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">floyd_warshall</span>(<span class="params">graph</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(graph)</span><br><span class="line">    dist = [[INF] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始化距离矩阵</span></span><br><span class="line">    <span class="keyword">for</span> u <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> v, weight <span class="keyword">in</span> graph[u]:</span><br><span class="line">            dist[u][v] = weight</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 迭代更新</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> dist[i][k] + dist[k][j] &lt; dist[i][j]:</span><br><span class="line">                    dist[i][j] = dist[i][k] + dist[k][j]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dist</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h3><p>在 BFS 算法框架详解 用的是普通的队列 Queue 来遍历多叉树，而对于加权图的最短路径来说，得用优先级队列 PriorityQueue自动排序的特性，将路径权重较小的节点排在队列前面，以此为基础施展 BFS 算法，也就变成了 Dijkstra 算法。</p>
<p>Dijkstra 算法是一种用于解决带有非负权边的单源最短路径问题的算法。它能够找到从起点到图中所有其他顶点的最短路径。</p>
<ul>
<li>基本思想：通过逐步松弛顶点来逐步确定最短路径。它维护一个距离数组，记录从起点到每个顶点的最短路径估计值。算法的迭代过程中，每次选择距离数组中值最小的顶点，并对其邻接顶点进行松弛操作，更新距离数组中的值。通过不断选择最短路径估计值最小的顶点，最终可以确定起点到其他所有顶点的最短路径。Dijkstra 可以理解成一个带 dp table（或者说备忘录）的 BFS 算法。</li>
<li>算法条件：加权有向图，没有负权重边</li>
<li>基本步骤：<ol>
<li>初始化：将起点的距离设为 0，其余顶点的距离设为无穷大。</li>
<li>迭代更新：重复以下步骤，直到所有顶点都被处理或者没有可选顶点为止：选择距离数组中值最小的顶点作为当前顶点；对当前顶点的邻接顶点进行松弛操作，更新距离数组中的值。</li>
<li>返回结果：最终的距离数组就是起点到所有顶点的最短路径。</li>
</ol>
</li>
<li>时间复杂度： O(ElogV)，其中 E 代表图中边的条数，V 代表图中节点的个数。因为理想情况下优先级队列中最多装 V 个节点，对优先级队列的操作次数和 E 成正比，所以整体的时间复杂度就是 O(ElogV)。</li>
<li>代码：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line">INF = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dijkstra</span>(<span class="params">graph, start</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(graph)</span><br><span class="line">    distance = [INF] * n</span><br><span class="line">    distance[start] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    min_heap = [(<span class="number">0</span>, start)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> min_heap:</span><br><span class="line">        dist, u = heapq.heappop(min_heap)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果当前顶点已经处理过，则跳过</span></span><br><span class="line">        <span class="keyword">if</span> dist &gt; distance[u]:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> v, weight <span class="keyword">in</span> graph[u]:</span><br><span class="line">            new_dist = distance[u] + weight</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果找到了更短的路径，则更新距离数组和堆中的值</span></span><br><span class="line">            <span class="keyword">if</span> new_dist &lt; distance[v]:</span><br><span class="line">                distance[v] = new_dist</span><br><span class="line">                heapq.heappush(min_heap, (new_dist, v))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> distance</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Bellman-Ford"><a href="#Bellman-Ford" class="headerlink" title="Bellman-Ford"></a>Bellman-Ford</h3><p>Bellman-Ford 算法是一种用于解决带有负权边的单源最短路径问题的算法。它可以应对图中存在负权边和负权环的情况。</p>
<ul>
<li>基本思想：通过逐步松弛边的权重来逐步逼近最短路径。它维护一个距离数组，记录从起点到每个顶点的最短路径估计值。算法的迭代过程中，通过对每条边进行松弛操作，不断更新距离数组中的值，直到无法再进行松弛为止。</li>
<li>基本步骤：<ol>
<li>初始化：将起点的距离设为 0，其余顶点的距离设为无穷大。</li>
<li>迭代更新：对于图中的每条边，逐步松弛边的权重。对于边 (u, v) 来说，如果从起点到顶点 u 的路径经过边 (u, v) 能够获得更短的路径，则更新顶点 v 的距离值。</li>
<li>检测负权环：在迭代更新的过程中，如果存在顶点的距离值发生变化，则说明图中存在负权环。由于负权环可以无限次地减小路径的长度，因此 Bellman-Ford 算法可以通过检测负权环来判断是否存在无限小的最短路径。</li>
<li>返回结果：如果不存在负权环，则最终的距离数组就是起点到所有顶点的最短路径。</li>
</ol>
</li>
<li>时间复杂度：O(V * E)，其中 V 是顶点的数量，E 是边的数量。</li>
<li>代码：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">INF = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bellman_ford</span>(<span class="params">graph, start</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(graph)</span><br><span class="line">    distance = [INF] * n</span><br><span class="line">    distance[start] = <span class="number">0</span></span><br><span class="line">    predecessor = [-<span class="number">1</span>] * n</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> u <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> v, weight <span class="keyword">in</span> graph[u]:</span><br><span class="line">                <span class="keyword">if</span> distance[u] != INF <span class="keyword">and</span> distance[u] + weight &lt; distance[v]:</span><br><span class="line">                    distance[v] = distance[u] + weight</span><br><span class="line">                    predecessor[v] = u</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 检测负权环</span></span><br><span class="line">    <span class="keyword">for</span> u <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> v, weight <span class="keyword">in</span> graph[u]:</span><br><span class="line">            <span class="keyword">if</span> distance[u] != INF <span class="keyword">and</span> distance[u] + weight &lt; distance[v]:</span><br><span class="line">                <span class="keyword">raise</span> ValueError(<span class="string">&quot;Graph contains a negative weight cycle.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># # Check for negative-weight cycles，并记录环路径negative_cycle</span></span><br><span class="line">    <span class="comment"># negative_cycle = None</span></span><br><span class="line">    <span class="comment"># for u in range(n):</span></span><br><span class="line">    <span class="comment">#     for v, weight in graph[u]:</span></span><br><span class="line">    <span class="comment">#         if distance[u] + weight &lt; distance[v]:</span></span><br><span class="line">    <span class="comment">#             # Negative-weight cycle found</span></span><br><span class="line">    <span class="comment">#             negative_cycle = []</span></span><br><span class="line">    <span class="comment">#             cycle_vertex = v</span></span><br><span class="line">    <span class="comment">#             while cycle_vertex not in negative_cycle:</span></span><br><span class="line">    <span class="comment">#                 negative_cycle.append(cycle_vertex)</span></span><br><span class="line">    <span class="comment">#                 cycle_vertex = predecessor[cycle_vertex]</span></span><br><span class="line">    <span class="comment">#             negative_cycle.append(cycle_vertex)</span></span><br><span class="line">    <span class="comment">#             negative_cycle.reverse()</span></span><br><span class="line">    <span class="comment">#             break</span></span><br><span class="line">    <span class="comment">#     if negative_cycle is not None:</span></span><br><span class="line">    <span class="comment">#         break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> distance</span><br><span class="line"></span><br><span class="line">graph = [</span><br><span class="line">    [(<span class="number">1</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">2</span>)],</span><br><span class="line">    [(<span class="number">3</span>, <span class="number">3</span>)],</span><br><span class="line">    [(<span class="number">1</span>, <span class="number">1</span>), (<span class="number">3</span>, -<span class="number">5</span>)],</span><br><span class="line">    [(<span class="number">4</span>, <span class="number">2</span>)],</span><br><span class="line">    []</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">start_vertex = <span class="number">0</span></span><br><span class="line">distances = bellman_ford(graph, start_vertex)</span><br><span class="line"><span class="built_in">print</span>(distances)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h3><p>SPFA（Shortest Path Faster Algorithm）是一种用于求解带有负权边的单源最短路径问题的算法。它是对 Bellman-Ford 算法的一种优化，通过使用队列进行松弛操作的选择，减少了不必要的重复操作，从而提高了算法的效率。</p>
<ul>
<li>基本步骤：</li>
</ul>
<ol>
<li>初始化：将起点的距离设为 0，其余顶点的距离设为无穷大。将起点加入队列中。</li>
<li>迭代更新：从队列中取出一个顶点，并对其邻接顶点进行松弛操作。如果通过当前顶点 u 可以获得更短的路径，则更新邻接顶点 v 的距离值，并将 v 加入队列中（如果 v 不在队列中）。继续迭代，直到队列为空。</li>
<li>检测负权环：通过统计每个顶点的入队次数来实现的。如果某个顶点入队的次数超过图中顶点的数量，即超过了 n 次（n 是顶点的数量），则说明存在负权环。</li>
<li>返回结果：如果不存在负权环，则最终的距离数组就是起点到所有顶点的最短路径。</li>
</ol>
<ul>
<li>时间复杂度：一般情况下的时间复杂度是 O(kE)，其中 k 是松弛操作的次数，E 是边的数量。在大多数情况下，SPFA 算法的运行时间要比 Bellman-Ford 算法更快。</li>
<li>代码：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line">INF = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spfa</span>(<span class="params">graph, start</span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(graph)</span><br><span class="line">    distance = [INF] * n</span><br><span class="line">    distance[start] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    queue = deque()</span><br><span class="line">    queue.append(start)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 记录每个顶点入队的次数。如果某个顶点的入队次数超过 n 次，则直接返回 &quot;存在负权环&quot;。</span></span><br><span class="line">    count = [<span class="number">0</span>] * n</span><br><span class="line">    count[start] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        u = queue.popleft()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> v, weight <span class="keyword">in</span> graph[u]:</span><br><span class="line">            new_dist = distance[u] + weight</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> new_dist &lt; distance[v]:</span><br><span class="line">                distance[v] = new_dist</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> v <span class="keyword">not</span> <span class="keyword">in</span> queue:</span><br><span class="line">                    queue.append(v)</span><br><span class="line">                    count[v] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 检测负权环</span></span><br><span class="line">                    <span class="keyword">if</span> count[v] &gt; n:</span><br><span class="line">                        <span class="keyword">return</span> <span class="string">&quot;存在负权环&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> distance</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="A-算法"><a href="#A-算法" class="headerlink" title="A*算法"></a>A*算法</h3><p>A*算法是一种启发式搜索算法，用于在图形表示的问题中找到最短路径或最优解。它结合了Dijkstra算法的广度优先搜索和贪心算法的启发式评估，以在搜索过程中更快地找到目标。</p>
<ul>
<li>基本思想：通过维护一个开放列表和一个关闭列表来搜索图形中的节点。开放列表存储待扩展的节点，而关闭列表存储已经访问过的节点。在每一步中，A算法根据节点的启发式评估值选择最有希望的节点进行扩展。这个启发式评估值通常是一个估计值，用于预测从当前节点到目标节点的最短路径代价。</li>
<li>基本步骤：<ol>
<li>将起点加入开放列表，并设置起点的启发式评估值（例如，预估的从起点到目标节点的最短路径代价）。</li>
<li>重复以下步骤直到找到目标节点或开放列表为空：从开放列表中选择启发式评估值最低的节点作为当前节点。将当前节点从开放列表中移除，并将其加入关闭列表。如果当前节点是目标节点，搜索结束，找到了最短路径或最优解。否则，对当前节点的所有邻接节点进行如下操作：如果邻接节点已经在关闭列表中，则跳过该节点。如果邻接节点不在开放列表中，将其加入开放列表，并计算它的启发式评估值。如果邻接节点已经在开放列表中，更新其启发式评估值为更低的值（如果需要）。</li>
<li>如果开放列表为空，表示无法到达目标节点，搜索结束。</li>
</ol>
</li>
<li>注意：A算法的效率和搜索结果的质量高度依赖于所选择的启发式评估函数。一个合理的启发式评估函数能够提供较为准确的路径代价估计，从而指导搜索过程朝着最有希望的方向前进。但如果启发式评估函数不准确或不适当，可能会导致搜索结果不是最优解或搜索效率较低。因此，在使用A算法时，选择和设计合适的启发式评估函数非常重要。</li>
<li>代码：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heuristic</span>(<span class="params">node, goal</span>):</span></span><br><span class="line">    <span class="comment"># 启发式评估函数，计算当前节点到目标节点的估计代价</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(node[<span class="number">0</span>] - goal[<span class="number">0</span>]) + <span class="built_in">abs</span>(node[<span class="number">1</span>] - goal[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">astar</span>(<span class="params">graph, start, goal</span>):</span></span><br><span class="line">    <span class="comment"># 初始化数据结构</span></span><br><span class="line">    open_list = []</span><br><span class="line">    closed_set = <span class="built_in">set</span>()</span><br><span class="line">    came_from = &#123;&#125;</span><br><span class="line">    g_score = &#123;start: <span class="number">0</span>&#125;</span><br><span class="line">    f_score = &#123;start: heuristic(start, goal)&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将起点加入开放列表</span></span><br><span class="line">    heapq.heappush(open_list, (f_score[start], start))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> open_list:</span><br><span class="line">        current = heapq.heappop(open_list)[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> current == goal:</span><br><span class="line">            <span class="comment"># 找到目标节点，构建路径并返回</span></span><br><span class="line">            path = []</span><br><span class="line">            <span class="keyword">while</span> current <span class="keyword">in</span> came_from:</span><br><span class="line">                path.append(current)</span><br><span class="line">                current = came_from[current]</span><br><span class="line">            path.append(start)</span><br><span class="line">            <span class="keyword">return</span> path[::-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        closed_set.add(current)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> neighbor <span class="keyword">in</span> graph[current]:</span><br><span class="line">            <span class="keyword">if</span> neighbor <span class="keyword">in</span> closed_set:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 计算当前节点到邻接节点的实际代价</span></span><br><span class="line">            tentative_g_score = g_score[current] + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> neighbor <span class="keyword">not</span> <span class="keyword">in</span> open_list:</span><br><span class="line">                open_list.append((f_score.get(neighbor, <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)), neighbor))</span><br><span class="line">            <span class="keyword">elif</span> tentative_g_score &gt;= g_score.get(neighbor, <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            came_from[neighbor] = current</span><br><span class="line">            g_score[neighbor] = tentative_g_score</span><br><span class="line">            f_score[neighbor] = tentative_g_score + heuristic(neighbor, goal)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 开放列表为空，无法到达目标节点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例使用</span></span><br><span class="line">graph = &#123;</span><br><span class="line">    (<span class="number">0</span>, <span class="number">0</span>): [(<span class="number">0</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>)],</span><br><span class="line">    (<span class="number">0</span>, <span class="number">1</span>): [(<span class="number">0</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">1</span>)],</span><br><span class="line">    (<span class="number">1</span>, <span class="number">0</span>): [(<span class="number">0</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">0</span>)],</span><br><span class="line">    (<span class="number">1</span>, <span class="number">1</span>): [(<span class="number">0</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">2</span>, <span class="number">1</span>)],</span><br><span class="line">    (<span class="number">2</span>, <span class="number">0</span>): [(<span class="number">1</span>, <span class="number">0</span>), (<span class="number">2</span>, <span class="number">1</span>)],</span><br><span class="line">    (<span class="number">2</span>, <span class="number">1</span>): [(<span class="number">1</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">0</span>)]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">start = (<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">goal = (<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">path = astar(graph, start, goal)</span><br><span class="line"><span class="keyword">if</span> path:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;找到最短路径：&quot;</span>, path)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;无法到达目标节点&quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="力扣指南"><a href="#力扣指南" class="headerlink" title="力扣指南"></a>力扣指南</h2><table>
    <tr>
        <th align='center', colspan="3">图论</th>
    </tr>
    <tr>
        <th>题目</th>
        <th>技巧</th>
        <th>难度</th>
    </tr>
    <tr>
        <td><a href=https://leetcode.cn/problems/all-paths-from-source-to-target/description>✅797. 所有可能的路径</td>
        <td>经典回溯</td> 
        <td>🌟🌟</td> 
    </tr>
    <tr> 
        <td><a href=https://leetcode.cn/problems/course-schedule/description>✅207. 课程表</td>
        <td></td> 
        <td>🌟🌟</td> 
    </tr>
    <tr>
        <td><a href=https://leetcode.cn/problems/course-schedule-ii/description>✅210. 课程表 II</td>
        <td>拓扑排序</td> 
        <td>🌟🌟</td> 
    </tr>
    <tr>
        <td><a href=https://leetcode.cn/problems/is-graph-bipartite/description>✅785. 判断二分图</td>
        <td></td> 
        <td>🌟</td> 
    </tr>
    <tr>
        <td><a href=https://leetcode.cn/problems/possible-bipartition/description>✅886. 可能的二分法</td>
        <td></td> 
        <td>🌟🌟</td> 
    </tr>
    <tr>
        <td><a href=https://leetcode.cn/problems/surrounded-regions/description>✅130. 被围绕的区域</td>
        <td>并查集</td> 
        <td>🌟🌟</td> 
    </tr>
    <tr>
        <td><a href=https://leetcode.cn/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/description>✅1334. 阈值距离内邻居最少的城市</td>
        <td>Floyd</td> 
        <td>🌟🌟</td> 
    </tr>
    <tr>
        <td><a href=https://leetcode.cn/problems/minimum-cost-to-convert-string-i>✅2976. 转换字符串的最小成本 I</td>
        <td>Floyd</td> 
        <td>🌟🌟</td> 
    </tr>
    <tr>
        <td><a href=https://leetcode.cn/problems/satisfiability-of-equality-equations/description>✅990. 等式方程的可满足性</td>
        <td>Kruskal 算法</td> 
        <td>🌟🌟</td> 
    </tr>
    <tr>
        <td><a href=https://leetcode.cn/problems/min-cost-to-connect-all-points/description>✅1584. 连接所有点的最小费用</td>
        <td>Kruskal + prim</td> 
        <td>🌟🌟</td> 
    </tr>
    <tr>
        <td><a href=https://leetcode.cn/problems/network-delay-time/description>✅743. 网络延迟时间</td>
        <td>标准dijkstra</td> 
        <td>🌟🌟</td> 
    </tr>
    <tr>
        <td><a href=https://leetcode.cn/problems/path-with-minimum-effort/description>✅1631. 最小体力消耗路径</td>
        <td>从上下左右都更新时用图</td> 
        <td>🌟🌟</td> 
    </tr>
    <tr>
        <td><a href=https://leetcode.cn/problems/path-with-maximum-probability/description>✅1514. 概率最大的路径</td>
        <td>无向图是双向图</td> 
        <td>🌟🌟</td> 
    </tr>
    <tr>
        <td><a href=https://leetcode.cn/problems/find-the-town-judge/description>✅997. 找到小镇的法官</td>
        <td>计算出入度</td> 
        <td>🌟</td> 
    </tr>
    <tr>
        <td><a href=https://leetcode.cn/problems/cheapest-flights-within-k-stops/description>✅787. K 站中转内最便宜的航班</td>
        <td>dijkstra、DP</td> 
        <td>🌟🌟</td> 
    </tr>
</table>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">贪钱算法还我头发</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://xfliu1998.github.io/2023/06/04/Graph-Theory/">https://xfliu1998.github.io/2023/06/04/Graph-Theory/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Data-Structures-and-Algorithms/">Data Structures and Algorithms</a><a class="post-meta__tags" href="/tags/LeetCode/">LeetCode</a></div><div class="post_share"><div class="social-share" data-image="http://img.shijue.me/845aa0476235409e9ef646afb7c05ab7_d.jpg!dp6" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/06/05/Interview-Experience/"><img class="prev-cover" src="http://img.shijue.me/00964c481ad34d78acbf148d2b391c9e_d.jpg!dp6" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">Interview Experience</div></div></a></div><div class="next-post pull-right"><a href="/2023/05/29/Divide-and-Conquer/"><img class="next-cover" src="http://img.shijue.me/d5e5c8cc7dae431386f1d15c0006f217.jpg!dp6" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">Divide and Conquer</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2023/07/05/Number-Theory-and-Geometry/" title="Number Theory and Geometry"><img class="cover" src="http://img.shijue.me/d9a0b9ce22d44e6f9213e5ef8917385d_d.jpg!dp6" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-05</div><div class="title">Number Theory and Geometry</div></div></a></div><div><a href="/2023/06/13/Sort-Algorithm/" title="Sort Algorithm"><img class="cover" src="http://img.shijue.me/05adac4bd8b1447697e1053623e74d68_d.jpg!dp6" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-13</div><div class="title">Sort Algorithm</div></div></a></div><div><a href="/2023/05/29/Divide-and-Conquer/" title="Divide and Conquer"><img class="cover" src="http://img.shijue.me/d5e5c8cc7dae431386f1d15c0006f217.jpg!dp6" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-29</div><div class="title">Divide and Conquer</div></div></a></div><div><a href="/2023/05/21/Greedy-Algorithm/" title="Greedy Algorithm"><img class="cover" src="http://img.shijue.me/73abae19e7ed4f279380e078361cafff_d.jpg!dp6" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-21</div><div class="title">Greedy Algorithm</div></div></a></div><div><a href="/2023/04/19/Dynamic-Programming/" title="Dynamic Programming"><img class="cover" src="http://img.shijue.me/eb9640e472e540b4bce2f24b9f11237d_d.jpg!dp6" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-19</div><div class="title">Dynamic Programming</div></div></a></div><div><a href="/2023/04/12/Search-and-Backstrack/" title="Search and Backstrack"><img class="cover" src="https://www.omegaxyz.com/wp-content/uploads/2019/05/recall.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-12</div><div class="title">Search and Backstrack</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comment</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/images/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">贪钱算法还我头发</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">57</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">15</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">6</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xfliu1998"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/xfliu1998" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:liuxiaofei_7@163.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://blog.csdn.net/keiven_" target="_blank" title="CSDN"><i class="fa fa-address-card"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>Announcement</span></div><div class="announcement_content">欢迎来这里掉头发</div></div><div class="card-widget" id="newYear"><div class="item-headline"><i></i><span></span></div><div class="item-content"><div id="newYear-main"><div class="mask"></div> <p class="title"></p> <div class="newYear-time"></div> <p class="today" style="text-align: right;"></p> </div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%BE%E8%AE%BA"><span class="toc-number">1.</span> <span class="toc-text">图论</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E5%9B%BE%E7%AE%97%E6%B3%95"><span class="toc-number">1.1.</span> <span class="toc-text">常见图算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-number">1.1.1.</span> <span class="toc-text">拓扑排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E5%9B%BE"><span class="toc-number">1.1.2.</span> <span class="toc-text">二分图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-number">1.1.3.</span> <span class="toc-text">并查集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">1.1.4.</span> <span class="toc-text">最小生成树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95"><span class="toc-number">1.2.</span> <span class="toc-text">最短路径算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Floyd-Warshall"><span class="toc-number">1.2.1.</span> <span class="toc-text">Floyd-Warshall</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dijkstra"><span class="toc-number">1.2.2.</span> <span class="toc-text">Dijkstra</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bellman-Ford"><span class="toc-number">1.2.3.</span> <span class="toc-text">Bellman-Ford</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SPFA"><span class="toc-number">1.2.4.</span> <span class="toc-text">SPFA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#A-%E7%AE%97%E6%B3%95"><span class="toc-number">1.2.5.</span> <span class="toc-text">A*算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%9B%E6%89%A3%E6%8C%87%E5%8D%97"><span class="toc-number">1.3.</span> <span class="toc-text">力扣指南</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('http://img.shijue.me/845aa0476235409e9ef646afb7c05ab7_d.jpg!dp6')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025  <i id="heartbeat" class="fa fas fa-heartbeat"></i> 贪钱算法还我头发</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div><head><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"></head></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="Scroll To Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>function addGitalkSource () {
  const ele = document.createElement('link')
  ele.rel = 'stylesheet'
  ele.href= 'https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css'
  document.getElementsByTagName('head')[0].appendChild(ele)
}

function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: '1b0c10ce649501ea4a72',
      clientSecret: '741b5e861137e3d5a482bba272c8201b78da6cb0',
      repo: 'xfliu1998.github.io',
      owner: 'xfliu1998',
      admin: ['xfliu1998'],
      id: '8ba27e8a32bf67bf92a4ce9812399ff3',
      language: 'en',
      perPage: 10,
      distractionFreeMode: false,
      pagerDirection: 'last',
      createIssueManually: true,
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    addGitalkSource()
    getScript('https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !false) {
  if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div><script src="/js/script.js?v1"></script><script src="https://cdn.staticfile.org/jquery/3.6.3/jquery.min.js"></script><script async data-pjax src="https://cdn.wpon.cn/2022-sucai/Gold-ingot.js"></script><script async data-pjax src="/js/newYear.js"></script><script async src="//at.alicdn.com/t/font_2264842_b004iy0kk2b.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --> <script data-pjax>if(document.getElementById('recent-posts') && (location.pathname ==='all'|| 'all' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="https://xfliu1998.github.io/categories/Machine-Learning-and-Deep-Learning/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">👩‍💻 机器学习与深度学习 (12)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://xfliu1998.github.io/categories/Data-Structures-and-Algorithms/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">😼 数据结构与算法 (16)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://xfliu1998.github.io/categories/Search-Advertisement-Recommendation-Causal/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🗂️ 搜索/广告/推荐/因果 (10)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://xfliu1998.github.io/categories/Data-Analysis-and-Processing/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📒 数据分析与处理 (7)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://xfliu1998.github.io/categories/Reading-Notes/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📚 阅读笔记 (8)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://xfliu1998.github.io/categories/Daily/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">💡 日常随想 (4)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><a class="magnet_link_more"  href="https://xfliu1998.github.io/categories" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(50% - 5px);background: #f2f2f2;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: #b30070}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:white}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2022/09/17/Papers-Reading-about-NLP/" alt=""><img width="48" height="48" src="https://tse1-mm.cn.bing.net/th/id/OIP-C.KNjcp6IetyzFaIaSc8-eKAHaE8?w=303&amp;h=201&amp;c=7&amp;r=0&amp;o=5&amp;dpr=1.88&amp;pid=1.7" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-09-17</span><a class="blog-slider__title" href="2022/09/17/Papers-Reading-about-NLP/" alt="">Papers Reading about NLP</a><div class="blog-slider__text">自然语言处理论文阅读笔记</div><a class="blog-slider__button" href="2022/09/17/Papers-Reading-about-NLP/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2022/10/01/9-3D-Construction/" alt=""><img width="48" height="48" src="https://img.zcool.cn/community/017d495d0e6a9ea801205e4b7fa13c.png@1280w_1l_2o_100sh.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-10-01</span><a class="blog-slider__title" href="2022/10/01/9-3D-Construction/" alt="">3D Construction</a><div class="blog-slider__text">三维重建基础</div><a class="blog-slider__button" href="2022/10/01/9-3D-Construction/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2023/01/11/SfM-SLAM/" alt=""><img width="48" height="48" src="https://tse2-mm.cn.bing.net/th/id/OIP-C.V5uTTQ6LTBHc42xoBPG8hAHaEm?pid=ImgDet&amp;rs=1" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-01-11</span><a class="blog-slider__title" href="2023/01/11/SfM-SLAM/" alt="">SfM &amp; SLAM</a><div class="blog-slider__text">SfM和SLAM系统</div><a class="blog-slider__button" href="2023/01/11/SfM-SLAM/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2023/03/25/Papers-Ideas/" alt=""><img width="48" height="48" src="https://tse2-mm.cn.bing.net/th/id/OIP-C.Mmv8iGEVFxSQII6QH0BG9QHaEJ?w=302&amp;h=180&amp;c=7&amp;r=0&amp;o=5&amp;dpr=2&amp;pid=1.7" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-03-25</span><a class="blog-slider__title" href="2023/03/25/Papers-Ideas/" alt="">Papers Ideas</a><div class="blog-slider__text">大模型时代下的科研思路</div><a class="blog-slider__button" href="2023/03/25/Papers-Ideas/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2022/09/17/Papers-Summary/" alt=""><img width="48" height="48" src="https://tse1-mm.cn.bing.net/th/id/OIP-C.KNjcp6IetyzFaIaSc8-eKAHaE8?w=303&amp;h=201&amp;c=7&amp;r=0&amp;o=5&amp;dpr=1.88&amp;pid=1.7" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-09-17</span><a class="blog-slider__title" href="2022/09/17/Papers-Summary/" alt="">Papers Summary</a><div class="blog-slider__text">论文总结笔记</div><a class="blog-slider__button" href="2022/09/17/Papers-Summary/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2022/09/17/Papers-Reading-about-CV/" alt=""><img width="48" height="48" src="https://tse1-mm.cn.bing.net/th/id/OIP-C.KNjcp6IetyzFaIaSc8-eKAHaE8?w=303&amp;h=201&amp;c=7&amp;r=0&amp;o=5&amp;dpr=1.88&amp;pid=1.7" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-09-17</span><a class="blog-slider__title" href="2022/09/17/Papers-Reading-about-CV/" alt="">Papers Reading about CV</a><div class="blog-slider__text">计算机视觉论文阅读笔记</div><a class="blog-slider__button" href="2022/09/17/Papers-Reading-about-CV/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2023/06/05/Interview-Experience/" alt=""><img width="48" height="48" src="http://img.shijue.me/00964c481ad34d78acbf148d2b391c9e_d.jpg!dp6" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-06-05</span><a class="blog-slider__title" href="2023/06/05/Interview-Experience/" alt="">Interview Experience</a><div class="blog-slider__text">面经八股</div><a class="blog-slider__button" href="2023/06/05/Interview-Experience/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/08/16/Papers-Reading-about-LLM/" alt=""><img width="48" height="48" src="http://img.shijue.me/9ce88483789847cebe8d38fd7a77f7c7_d.jpg!dp6" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-08-16</span><a class="blog-slider__title" href="2024/08/16/Papers-Reading-about-LLM/" alt="">Papers Reading about LLM</a><div class="blog-slider__text">LLM论文阅读笔记</div><a class="blog-slider__button" href="2024/08/16/Papers-Reading-about-LLM/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2022/01/21/Learning-Framework/" alt=""><img width="48" height="48" src="http://img.shijue.me/78ae8b05a73444cd9643a8312abc0d43.jpg!dp6" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-01-21</span><a class="blog-slider__title" href="2022/01/21/Learning-Framework/" alt="">Learning Framework</a><div class="blog-slider__text">学习大纲</div><a class="blog-slider__button" href="2022/01/21/Learning-Framework/" alt="">详情   </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><script data-pjax src="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.js"></script><script data-pjax>
  function gitcalendar_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<container><style>#git_container{min-height: 280px}@media screen and (max-width:650px) {#git_container{min-height: 0px}}</style><div id="git_loading" style="width:10%;height:100%;margin:0 auto;display: block;"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animatetransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animatetransform></path></svg><style>#git_container{display: none;}</style></div><div id="git_container"></div></container>';
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      console.log('已挂载gitcalendar')
      }

    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
        gitcalendar_injector_config()
        GitCalendarInit("https://gitcalendar.fomal.cc/api?xfliu1998",['#d9e0df', '#c6e0dc', '#a8dcd4', '#9adcd2', '#89ded1', '#77e0d0', '#5fdecb', '#47dcc6', '#39dcc3', '#1fdabe', '#00dab9'],'xfliu1998')
    }
  </script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/haruto.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>